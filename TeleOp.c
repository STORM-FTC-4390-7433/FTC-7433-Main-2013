#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HiTeGyro,       sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     hangLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     conveyorDrive, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     conveyorTurn,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rightDrive,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     leftDrive,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     hangRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     flagDrive,     tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define COMPETITION

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drive.h"
#include "drive.c"
#include "conveyor.h"
#include "conveyor.c"
#include "hang.h"
#include "hang.c"
#include "gyro.h"
gyroSys gyr;
#include "gyro.c"
#include "flag.h"
#include "flag.c"

float compassNorm(tSensors comp, float compOff);

DriveSys drive;
ConvSys conv;
HangSys hang;
FlagSys flag;

void initializeRobot(){
	drive.Left = leftDrive;
	drive.Right = rightDrive;

	conv.driveMotor = conveyorDrive;
	conv.turnMotor = conveyorTurn;

	hang.leftRaise = hangLeft;
	hang.rightRaise = hangRight;
	hang.targetMoveTime = 100000;

	flag.drive = flagDrive;

	gyr.gyroscope = HiTeGyro;
	initGyroSys(gyr, 1000);
	gyr.readFreq = 1;
	StartTask(findHeading, 10);
	wait1Msec(1000);

	return;
}

task main(){

	initializeRobot();

	#ifdef COMPETITION
	waitForStart();   // wait for start of tele-op phase
	#endif

//	updateConvSys(conv, 100, 100);
	//	wait1Msec(500);
//	updateConvSys(conv, 0, 0);

	//float compassOffset;
	//compassOffset = SensorValue[HiTeCompass];
	//writeDebugStreamLine("compass %f", compassOffset);

	while (true){
		getJoystickSettings(joystick);

		updateGyroSys(gyr);
		//nxtDisplayString(0,"%f", gyr.currentHeading);
		//nxtDisplayString(1,"%f", compassNorm(HiTeCompass, compassOffset));
		//nxtDisplayString(3, "%f", abs(compassNorm(HiTeCompass, compassOffset) - gyr.currentHeading) <= 180 ? compassNorm(HiTeCompass, compassOffset) - gyr.currentHeading : 360 - (compassNorm(HiTeCompass, compassOffset) - gyr.currentHeading) );
		updateDriveSys(drive, joystick.joy1_y1 * (100.0/128.0), joystick.joy1_y2 * (100.0/128.0));
		updateConvSys(conv, joystick.joy2_y1 * (100.0/128.0 * 1.5), joystick.joy2_y2 * (100.0/(128.0 * 1.5)));
		updateHangSys(hang, 100, joy2Btn(4), joy2Btn(2));
		updateFlagSys(flag, 100, joystick.joy2_TopHat);
	}
}

float compassNorm(tSensors comp, float compOff){
	float temp = SensorValue[comp] - compOff;
	if(temp < 0.0){
		return (360.0 + temp);
	} else if (temp >= 360.0){
		return ((int)temp % 360);
	} else {
		return (temp);
	}
}
