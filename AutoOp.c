#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S2,     HiTeGyro,       sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     HiTeCompass,    sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     driveLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     driveRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     conveyorTurn,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     conveyorDrive, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     hangRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     hangLeft,      tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drive.h"
#include "drive.c"
#include "conveyor.h"
#include "conveyor.c"
#include "hang.h"
#include "hang.c"
#include "gyro.h"
gyroSys gyr;
#include "gyro.c"

DriveSys drive;
ConvSys conv;
HangSys hang;

void turnToAngle(DriveSys t, gyroSys g, float relHeading);
void driveToEncodeVal(DriveSys t, long targetVal);

void initializeRobot()
{
	drive.Left = driveLeft;
	drive.Right = driveRight;

	conv.driveMotor = conveyorDrive;
	conv.turnMotor = conveyorTurn;

	hang.leftRaise = hangLeft;
	hang.rightRaise = hangRight;

	gyr.gyroscope = HiTeGyro;
	initGyroSys(gyr, 1000);
	gyr.readFreq = 1;
	StartTask(findHeading, 10);
	wait1Msec(1000);
	return;
}

task main(){

	initializeRobot();

	#ifdef COMPETITION
	waitForStart();   // wait for start of tele-op phase
	#endif

	float compassOffset;
	compassOffset = SensorValue[HiTeCompass];
	writeDebugStreamLine("compass %f", compassOffset);


}

void turnToAngle(DriveSys t, gyroSys g, float relHeading, int turnRate){
	float targetHeading = gyr.rotationsHeading + relHeading;
	if(relHeading < 0){
		motor[t.Right] = turnRate;
		motor[t.Left] = - turnRate;
		while(gyr.rotationsHeading > targetHeading);
		motor[t.Right] = 0;
		motor[t.Left] = 0;
	} else if (relHeading > 0){
		motor[t.Right] = - turnRate;
		motor[t.Left] =  turnRate;
		while(gyr.rotationsHeading < targetHeading);
		motor[t.Right] = 0;
		motor[t.Left] = 0;
	} else {
		return;
	}
	return;
}

void driveToEncodeVal(DriveSys t, long targetVal){

}
