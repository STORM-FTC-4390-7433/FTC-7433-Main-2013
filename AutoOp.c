#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HiTeGyro,       sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     HiTeIR,         sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     hangLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     conveyorDrive, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     conveyorTurn2, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     conveyorTurn1, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rightDrive,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     leftDrive,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     hangRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     flagDrive,     tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#define COMPETITION
#include "JoystickDriver.c"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drive.h"
#include "drive.c"
#include "conveyor.h"
#include "conveyor.c"
#include "gyro.h"
gyroSys gyr;
#include "gyro.c"

DriveSys drive;
ConvSys conv;

void turnToAngle(DriveSys t, gyroSys g, float relHeading, int turnRate);
void driveToEncodeVal(DriveSys t, long targetVal, int leftMotorPower, int rightMotorPower);
void placeBlockOnIr(DriveSys t, gyroSys g, ConvSys s, bool isRightPath, tSensors IR);

void initializeRobot()
{
	drive.Left = leftDrive;
	drive.Right = rightDrive;

	conv.driveMotor = conveyorDrive;
	conv.turnMotor1 = conveyorTurn1;
	conv.turnMotor2 = conveyorTurn2;

	gyr.gyroscope = HiTeGyro;
	initGyroSys(gyr, 1000);
	gyr.readFreq = 1;
	StartTask(findHeading, 6);
	wait1Msec(1000);
	return;
}

task main(){
	driveToEncodeVal(drive, 1000, 100, 100);
	writeDebugStreamLine("yolo");
	return;
	writeDebugStreamLine("started");
	initializeRobot();
	writeDebugStreamLine("started 2");
	#ifdef COMPETITION
	waitForStart();   // wait for start of auto-op phase
	#endif
	//turnToAngle(drive, gyr, 360, 50);
		writeDebugStreamLine("started 20");
	driveToEncodeVal(drive, 2185, 100, 100);
		writeDebugStreamLine("started 21");
	turnToAngle(drive, gyr, 45, 100);
		writeDebugStreamLine("started 22");
	driveToEncodeVal(drive, -364, 100, 100);
		writeDebugStreamLine("started 23");
	writeDebugStreamLine("started 10");
	if(HTIRS2readDCDir(HiTeIR) == 5){
		turnToAngle(drive, gyr, -90, 50);
		wait1Msec(500);
		turnToAngle(drive, gyr, 90, 50);
	}

	driveToEncodeVal(drive, 1179, 100, 100);

	writeDebugStreamLine("started 11");
	if(HTIRS2readDCDir(HiTeIR) == 5){
		turnToAngle(drive, gyr, -90, 50);
		wait1Msec(500);
		turnToAngle(drive, gyr, 90, 50);
	}

		driveToEncodeVal(drive, 3408, 100, 100);
	writeDebugStreamLine("started 12");
	if(HTIRS2readDCDir(HiTeIR) == 5){
		turnToAngle(drive, gyr, -90, 50);
		wait1Msec(500);
		turnToAngle(drive, gyr, 90, 50);
	}

		driveToEncodeVal(drive, 1510, 100, 100);
	writeDebugStreamLine("started 13");
	if(HTIRS2readDCDir(HiTeIR) == 5){
		turnToAngle(drive, gyr, -90, 50);
		wait1Msec(500);
		turnToAngle(drive, gyr, 90, 50);
	}
	turnToAngle(drive, gyr, -13, 100);
	driveToEncodeVal(drive, 3353, 100, 100);
	turnToAngle(drive, gyr, -37, 100);
	driveToEncodeVal(drive, 4695, 100, 100);
	turnToAngle(drive, gyr, -38, 100);
	return;
	//driveToEncodeVal(drive, 10000, 50);
	/*PlayTone(3500, 500);
	while(bSoundActive);


	turnToAngle(drive, gyr, 90, 40);
	return;

	bool isDone = false;

	bool rightPath;

	while(!isDone){
		if(nNxtButtonPressed == 1){
			rightPath = true;
			isDone = true;

			PlayTone(2000, 100);
			while(bSoundActive);
		} else if(nNxtButtonPressed == 2){
			rightPath = false;
			isDone = true;

			PlayTone(5000, 100);
			while(bSoundActive);
		}
	}

	#ifdef COMPETITION
	waitForStart();   // wait for start of auto-op phase
	#endif

	//float compassOffset;
	//compassOffset = SensorValue[HiTeCompass];
	//writeDebugStreamLine("compass %f", compassOffset);

	//driveToEncodeVal(drive, 10000, 50);

	if(rightPath){
		driveToEncodeVal(drive, 200, 50); //get to end of scoring area
		turnToAngle(drive, gyr, -60.0, 25); //turn parallel to scoring area
		driveToEncodeVal(drive, 10, 50); //drive to first bin
		placeBlockOnIr(drive, gyr, conv, true, HiTeIR);
		driveToEncodeVal(drive, 10, 50); //drive to second bin
		placeBlockOnIr(drive, gyr, conv, true, HiTeIR);
		driveToEncodeVal(drive, 20, 50); //drive to third bin
		placeBlockOnIr(drive, gyr, conv, true, HiTeIR);
		driveToEncodeVal(drive, 10, 50); //drive to fourth bin
		placeBlockOnIr(drive, gyr, conv, true, HiTeIR);
		driveToEncodeVal(drive, 40, 50); //drive clear of scoring area
		turnToAngle(drive, gyr, 90, 25); //turn perpendicular to scoring area
		driveToEncodeVal(drive, 40, 50); //drive to spot clear on ramp
		turnToAngle(drive, gyr, 90, 25); //turn towards ramp
		driveToEncodeVal(drive, 40, 50); //drive up ramp
	} else {
		driveToEncodeVal(drive, 200, 50); //get to end of scoring area
		turnToAngle(drive, gyr, 60.0, 25); //turn parallel to scoring area AND BACKWARDS
		driveToEncodeVal(drive, -10, -50); //drive to first bin
		placeBlockOnIr(drive, gyr, conv, false, HiTeIR);
		driveToEncodeVal(drive, -10, -50); //drive to second bin
		placeBlockOnIr(drive, gyr, conv, false, HiTeIR);
		driveToEncodeVal(drive, -10, -50); //drive to third bin
		placeBlockOnIr(drive, gyr, conv, false, HiTeIR);
		driveToEncodeVal(drive, -10, -50); //drive to fourth bin
		placeBlockOnIr(drive, gyr, conv, false, HiTeIR);
		driveToEncodeVal(drive, -40, -50); //drive clear of scoring area
		turnToAngle(drive, gyr, -90.0, 25); //turn perpendicular to scoring area
		driveToEncodeVal(drive, -40, -50); //drive to spot clear on ramp
		turnToAngle(drive, gyr, -90, 25); //turn towards ramp
		driveToEncodeVal(drive, -40, -50); //drive up ramp
	}
	*/
}

void turnToAngle(DriveSys t, gyroSys g, float relHeading, int turnRate){
	float targetHeading = g.rotationsHeading + relHeading;
	writeDebugStreamLine("rotatHeading: %d", g.rotationsHeading);
	writeDebugStreamLine("relHerelHeading: %d", relHeading);
	writeDebugStreamLine("targetHeading: %d", targetHeading);
	if(relHeading < 0){
		motor[t.Right] = turnRate;
		motor[t.Left] = - turnRate;
		while(gyr.rotationsHeading > targetHeading);
		motor[t.Right] = 0;
		motor[t.Left] = 0;
	} else if (relHeading > 0){
		motor[t.Right] = - turnRate;
		motor[t.Left] =  turnRate;
		while(gyr.rotationsHeading < targetHeading){
			writeDebugStreamLine("rotationsHeading: %d", gyr.rotationsHeading);
			wait1Msec(10);
		}
		motor[t.Right] = 0;
		motor[t.Left] = 0;
	} else {
		return;
	}
	return;
}

void driveToEncodeVal(DriveSys t, long targetVal, int leftMotorPower, int rightMotorPower){
	nMotorEncoder[t.Right] = 0;

	writeDebugStreamLine("target: %d", targetVal);
	writeDebugStreamLine("left motor: %d", leftMotorPower);
	motor[t.Right] = rightMotorPower;
	wait1Msec(100);
	writeDebugStreamLine("right motor: %d", motor[t.Right]);
	motor[t.Left] = leftMotorPower;

	int iter = 0;
	while(abs(nMotorEncoder[t.Right]) < abs(targetVal)){
		nxtDisplayCenteredBigTextLine(0, "Enc %d", nMotorEncoder[t.Right]);
		iter++;
		writeDebugStreamLine("iters: %d", iter);
	};

	//writeDebugStreamLine()

	motor[t.Right] = 0;
	motor[t.Left] = 0;

	return;
}

void placeBlockOnIr(DriveSys t, gyroSys g, ConvSys s, bool isRightPath, tSensors IR){
	if(isRightPath){
		if(HTIRS2readDCDir(IR) == 5){
			turnToAngle(t, g, 90.0, 50);
			//updateConvSys(s, 0, 100);
			turnToAngle(t, g, -90.0, 50);
		}
	} else {
		if(HTIRS2readDCDir(IR) == 5){
			turnToAngle(t, g, -90.0, 50);
			//conveyor system
			turnToAngle(t, g, 90.0, 50);
		}
	}
}
